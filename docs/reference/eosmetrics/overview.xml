<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
  <!ENTITY % local.common.attrib "xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'">
]>
<chapter id="overview">
<title>Overview</title>
<refmeta>
<refentrytitle role="top_of_page" id="overview.top_of_page">Overview</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>
  EOSMETRICS Library
</refmiscinfo>
</refmeta>

<section>
<title>Introduction</title>
<para>
The EosMetrics library is designed for sending free-form data packets to an Endless Mobile analytics server.
It includes some convenience APIs for creating a few types of packets that several applications might want to send, but in general an application will decide for itself what the format of its metrics data packets will be.
</para>

<para>
Use the metrics library by creating an #EmtrSender object.
The #EmtrSender is mainly used through its emtr_sender_send_data() method; this method tries to send a data payload to the metrics server.
</para>

<para>
If for whatever reason the data cannot be sent, then it is queued to be sent later.
Your application should not care whether the data is sent or not; the emtr_sender_send_data() method will be successful even if the data was not sent, as long as it could be queued.
</para>

<para>
Queued data can be retried later using the emtr_sender_send_queued_data() method.
You could do this on application startup or shutdown, or when the system gains an internet connection.
</para>

<note><para>
  It is not yet determined whether the system will retry queued data in the default queue storage directory, or under what circumstances it will try to send previously queued data at all.
</para></note>

<para>
Data payloads are specified using #GVariant dictionaries (with type <code>a{sv}</code>).
They are converted into JSON data when sent.
They are also annotated with two extra properties: <code>machine</code> and <code>fingerprint</code>.
The <code>machine</code> property is a unique integer representing the hardware (or 0x1000000000000 if the platform does not have a unique way of identifying the hardware).
The <code>fingerprint</code> property is a unique string representing the current installation of the operating system.
</para>
</section>

<section>
<title>Example of sending</title>
<para>
Customize the #EmtrSender's properties according to what format of data you want to send.
Here is an example of using the convenience API to get a sender for sending application usage data:
</para>

|[
const EosMetrics = imports.gi.EosMetrics;

let sender = EosMetrics.Sender.new_for_app_usage_metrics();
let payload = EosMetrics.create_app_usage_payload('com.example.smoke-grinder', 300);
sender.send_data(payload, null, function (obj, res) {
    sender.send_data_finish(res);
});
// Your application does stuff here, including running the main loop
]|
</section>

<section>
<title>Customized data packets</title>
<para>
Here is an example of sending application-specific data, for a fictional SmokeGrinder application, that is not covered by the library's convenience API.
This example starts out by creating an #EmtrSender with a custom #EmtrConnection that posts the metrics data to <code>http://<varname>METRICS_SERVER_ADDRESS</varname>/ground_smoke</code> instead of the usual URI of <code>http://<varname>METRICS_SERVER_ADDRESS</varname>/metrics</code>.
You can pass the custom #EmtrConnection as a property to the constructor of #EmtrSender.
</para>

<para>
The metrics sender is a subclass of #EmtrSender; it could just as well be customized by setting its properties at construct time.
</para>

<para>
This sender also queues its data in its own separate queue, controlled by the #EmtrSender:storage-file property.
</para>

|[
const EosMetrics = imports.gi.EosMetrics;
const GLib = imports.gi.GLib;
const Lang = imports.lang;

// Custom sender class
const SmokeGrinderMetricsSender = new Lang.Class({
    Name: 'SmokeGrinderMetricsSender',
    Extends: EosMetrics.Sender,

    URI_CONTEXT: 'ground_smoke',
    FORM_PARAM_NAME: 'report',
    QUEUE_FILE_NAME: 'smoke_queue.json',

    _init: function (props) {
        props = props || {};
        let storage_dir = EosMetrics.get_default_storage_dir();
        props.storage_file = storage_dir.get_child(this.QUEUE_FILE_NAME);
        props.connection = new EosMetrics.Connection({
            form_param_name: this.FORM_PARAM_NAME,
            uri_context: this.URI_CONTEXT
        });
        this.parent(props);
    }
});

// Convenience function for creating the data payloads that this app sends
function create_payload(units, time) {
    return new GLib.Variant('a{sv}', {
        units_of_smoke_ground: new GLib.Variant('u', units),
        grinding_time: new GLib.Variant('u', time)
    });
}

// At application startup
let sender = new SmokeGrinderMetricsSender();

// When posting metrics data, e.g. reporting that 5 units of smoke were ground
// in 300 seconds
let payload = create_payload(5, 300);
sender.send_data(payload, null, function (obj, res) {
    sender.send_data_finish(res);
});
// Return control to the main loop, the data will be sent or queued without
// blocking your GUI
]|

<para>
This program will post a metrics data payload that looks something like this:
</para>

|[
{
    "report": {
        "units_of_smoke_ground": 5,
        "grinding_time": 300,
        "machine": 8796760435151,
        "fingerprint": "259c0c0a-e01e-4c73-8cab-bf8b38047471"
    }
}
]|

</section>

<section>
<title>Synchronous operation</title>
<para>
If you do not have a GUI to worry about, for example in a command-line utility, then use the #EmtrSender's emtr_sender_send_data_sync() and emtr_sender_send_queued_data_sync() methods to do blocking I/O.
</para>
</section>

</chapter>